
<!doctype html>
<meta charset="utf-8" />
<title>2D Shadow Simulator - Square + Draggable Light</title>
<style>
  html, body { height: 100%; margin: 0; }
  body { display: grid; place-items: center; background: #0e0f12; color: #eee; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto; }
  .panel { width: min(820px, 96vw); }
  #cv { width: 100%; height: auto; border: 1px solid #2b2d31; background: #0b0c10; display: block; }
  .ui { display: flex; gap: 12px; align-items: center; margin: 10px 0 6px; flex-wrap: wrap; }
  .ui small { opacity: 0.8; }
  label { font-size: 12px; display: flex; align-items: center; gap: 6px; }
  input[type=range] { width: 160px; }
</style>
<div class="panel">
  <div class="ui">
    <small>ライト（白点）をドラッグで移動できます。影（半透明グレー）はキャンバス端でクリップします。</small>
    <label>正方形サイズ <input id="size" type="range" min="40" max="280" value="160" /></label>
  </div>
  <canvas id="cv" width="800" height="500" aria-label="2D Shadow Simulator"></canvas>
</div>
<script>
(() => {
  const W = 800, H = 500;
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const sizeInput = document.getElementById('size');

  const state = {
    light: { x: 200, y: 80 },    // 初期ライト位置
    half: 80,                    // 正方形の半径（半辺）
    groundY: H - 80,             // 地面の高さ（下部）
    squareCenter: { x: W/2, y: H - 80 - 80 }, // 初期は地面に接地（bottom = groundY）
    dragging: false,
    dragOffset: { x: 0, y: 0 }
  };
  sizeInput.addEventListener('input', () => {
    state.half = +sizeInput.value / 2;
    // 正方形の底面が常に地面 y=groundY に接するように調整
    state.squareCenter.y = state.groundY - state.half;
    draw();
  });

  // ユーティリティ
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rayToCanvasBounds(L, V){
    // キャンバス矩形 [0,W]x[0,H]
    return rayToRectBounds(L, V, { xmin:0, xmax:W, ymin:0, ymax:H });
  }

  function rayToRectBounds(L, V, rect){
    // L + t*(V-L) が rect の境界に当たる最小 t>1 を返します
    const dx = V.x - L.x, dy = V.y - L.y;
    const ts = [];
    const EPS = 1e-6;
    // 垂直境界
    if (Math.abs(dx) > EPS){
      const tL = (rect.xmin - L.x)/dx; const yL = L.y + tL*dy; if (tL > 1 && yL >= rect.ymin - EPS && yL <= rect.ymax + EPS) ts.push({t:tL, x:rect.xmin, y:yL});
      const tR = (rect.xmax - L.x)/dx; const yR = L.y + tR*dy; if (tR > 1 && yR >= rect.ymin - EPS && yR <= rect.ymax + EPS) ts.push({t:tR, x:rect.xmax, y:yR});
    }
    // 水平境界
    if (Math.abs(dy) > EPS){
      const tT = (rect.ymin - L.y)/dy; const xT = L.x + tT*dx; if (tT > 1 && xT >= rect.xmin - EPS && xT <= rect.xmax + EPS) ts.push({t:tT, x:xT, y:rect.ymin});
      const tB = (rect.ymax - L.y)/dy; const xB = L.x + tB*dx; if (tB > 1 && xB >= rect.xmin - EPS && xB <= rect.xmax + EPS) ts.push({t:tB, x:xB, y:rect.ymax});
    }
    if (ts.length === 0) return { x: V.x, y: V.y };
    ts.sort((a,b)=>a.t-b.t);
    return { x: ts[0].x, y: ts[0].y };
  }

  function squareVertices(c, half){
    // 時計回り: 左上, 右上, 右下, 左下
    return [
      { x: c.x - half, y: c.y - half },
      { x: c.x + half, y: c.y - half },
      { x: c.x + half, y: c.y + half },
      { x: c.x - half, y: c.y + half }
    ];
  }

  function extremeIndicesFromLight(L, verts){
    // 頂点からライトへの角度を算出
    let ang = verts.map(v => Math.atan2(v.y - L.y, v.x - L.x));
    // 2通り（0基準／2π持ち上げ）を比較し、スパンが最小の方を採用
    function spanInfo(shift){
      const a = ang.map(A => A + (shift && A < 0 ? Math.PI*2 : 0));
      let minA = +Infinity, maxA = -Infinity, iMin = -1, iMax = -1;
      for (let i=0;i<a.length;i++){
        if (a[i] < minA){ minA = a[i]; iMin = i; }
        if (a[i] > maxA){ maxA = a[i]; iMax = i; }
      }
      return { span: maxA - minA, iMin, iMax };
    }
    const s0 = spanInfo(false);
    const s1 = spanInfo(true);
    const pick = (s1.span < s0.span) ? s1 : s0;
    return { iMin: pick.iMin, iMax: pick.iMax };
  }

  function walkIndicesCW(i, j, n){
    const path = [i];
    let k = i;
    while (k !== j){ k = (k+1)%n; path.push(k); }
    return path;
  }
  function walkIndicesCCW(i, j, n){
    const path = [i];
    let k = i;
    while (k !== j){ k = (k-1+n)%n; path.push(k); }
    return path;
  }

  function rayToGroundPlane(L, V){
    // 光源Lから頂点Vを通る光線が地面（y = groundY）と交差する点を求める
    const GY = state.groundY;
    // 光源が地面より下、または光線が上向きの場合は頂点そのものを返す
    if (L.y >= GY || V.y <= L.y) return { x: V.x, y: V.y };

    const dy = V.y - L.y;
    const dx = V.x - L.x;
    // t は L + t*(V-L) が地面に到達する係数
    const t = (GY - L.y) / dy;
    const x = L.x + t * dx;

    // キャンバス外にはみ出る場合はクリップ
    return { x: clamp(x, 0, W), y: GY };
  }

  function computeShadowPolygon(L, verts){
    // ライトから見た接線頂点（両端）を取得
    const { iMin, iMax } = extremeIndicesFromLight(L, verts);
    const n = verts.length;
    // 2 方向のうち短い方の辺列を採用
    const cw = walkIndicesCW(iMin, iMax, n);
    const ccw = walkIndicesCCW(iMin, iMax, n);
    const chain = (cw.length <= ccw.length) ? cw : ccw; // 遮蔽辺列

    const Vmin = verts[iMin];
    const Vmax = verts[iMax];
    const PfarMin = rayToGroundPlane(L, Vmin);
    const PfarMax = rayToGroundPlane(L, Vmax);

    // ポリゴン: 遮蔽辺列（Vmin→...→Vmax）→ PfarMax → PfarMin
    const poly = chain.map(idx => verts[idx]);
    poly.push(PfarMax);
    poly.push(PfarMin);
    return poly;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // 地面と空
    const GY = state.groundY;
    // 空
    ctx.fillStyle = '#0b0c10';
    ctx.fillRect(0,0,W,GY);
    // 地面
    ctx.fillStyle = '#12161c';
    ctx.fillRect(0,GY,W,H-GY);
    // 地面ライン
    ctx.strokeStyle = '#2f333a';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0,GY+0.5); ctx.lineTo(W,GY+0.5); ctx.stroke();
    // 地面の目地
    ctx.save();
    ctx.strokeStyle = '#1b2027';
    ctx.lineWidth = 1;
    for (let x=0; x<=W; x+=25){ ctx.beginPath(); ctx.moveTo(x,GY); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y=GY; y<=H; y+=25){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();

    // 正方形（底辺が地面に接する）
    const verts = squareVertices(state.squareCenter, state.half);

    // 影ポリゴン（地面矩形にクリップされた遠方点）
    const shadowPoly = computeShadowPolygon(state.light, verts);
    ctx.save();
    ctx.fillStyle = 'rgba(200,200,200,0.25)';
    ctx.strokeStyle = 'rgba(220,220,220,0.35)';
    ctx.beginPath();
    ctx.moveTo(shadowPoly[0].x, shadowPoly[0].y);
    for (let i=1;i<shadowPoly.length;i++) ctx.lineTo(shadowPoly[i].x, shadowPoly[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // 正方形本体
    ctx.save();
    ctx.fillStyle = '#3a9ad9';
    ctx.strokeStyle = '#87c2f1';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(verts[0].x, verts[0].y);
    for (let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // ライト
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#dddddd';
    ctx.beginPath();
    ctx.arc(state.light.x, state.light.y, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();

    // ライトからの補助線（接線）
    const { iMin, iMax } = extremeIndicesFromLight(state.light, verts);
    const L = state.light;
    const P1 = rayToCanvasBounds(L, verts[iMin]);
    const P2 = rayToCanvasBounds(L, verts[iMax]);
    ctx.globalAlpha = 0.6;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(L.x, L.y); ctx.lineTo(P1.x, P1.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(L.x, L.y); ctx.lineTo(P2.x, P2.y); ctx.stroke();
    ctx.restore();

    // 注記
    ctx.save();
    ctx.fillStyle = '#ddd';
    ctx.font = '12px system-ui, ui-sans-serif, -apple-system';
    ctx.fillText(`Light: (${Math.round(state.light.x)}, ${Math.round(state.light.y)})`, 10, 18);
    ctx.fillText(`Square half: ${state.half}px`, 10, 34);
    ctx.restore();
  }

  // ドラッグ操作
  function isOnLight(x,y){
    const dx = x - state.light.x, dy = y - state.light.y; return (dx*dx + dy*dy) <= 9*9;
  }
  cv.addEventListener('pointerdown', (e) => {
    const rect = cv.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (cv.width/rect.width);
    const y = (e.clientY - rect.top) * (cv.height/rect.height);
    if (isOnLight(x,y)){
      state.dragging = true;
      state.dragOffset.x = x - state.light.x;
      state.dragOffset.y = y - state.light.y;
      cv.setPointerCapture(e.pointerId);
    }
  });
  cv.addEventListener('pointermove', (e) => {
    if (!state.dragging) return;
    const rect = cv.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (cv.width/rect.width);
    const y = (e.clientY - rect.top) * (cv.height/rect.height);
    state.light.x = clamp(x - state.dragOffset.x, 0, W);
    state.light.y = clamp(y - state.dragOffset.y, 0, H);
    draw();
  });
  cv.addEventListener('pointerup', (e) => { state.dragging = false; cv.releasePointerCapture?.(e.pointerId); });
  cv.addEventListener('pointerleave', () => { state.dragging = false; });

  // 初回描画
  draw();
})();
</script>
